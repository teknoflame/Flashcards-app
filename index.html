<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <!-- Explicit referrer policy to ensure YouTube receives an origin (prevents error 153 when possible) -->
        <meta name="referrer" content="strict-origin-when-cross-origin">
    <title>StudyFlow - Accessible Flashcards Study App</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            line-height: 1.6;
            color: #333;
            background-color: #f5f5f5;
            padding: 20px;
        }

        .container {
            max-width: 900px;
            margin: 0 auto;
            background: white;
            padding: 30px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        h1, h2, h3 {
            margin-bottom: 15px;
            color: #2c3e50;
        }

        .nav-tabs {
            display: flex;
            border-bottom: 2px solid #dee2e6;
            margin-bottom: 30px;
        }

        .nav-tab {
            background: none;
            border: none;
            padding: 12px 20px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            border-bottom: 3px solid transparent;
            transition: all 0.2s;
        }

        .nav-tab:hover, .nav-tab:focus {
            background: #f8f9fa;
            outline: 2px solid #3498db;
            outline-offset: -2px;
        }

        .nav-tab.active {
            border-bottom-color: #3498db;
            color: #3498db;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        .section {
            margin-bottom: 30px;
        }

        label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #34495e;
        }

        input, textarea, select, button {
            width: 100%;
            padding: 12px;
            border: 2px solid #bdc3c7;
            border-radius: 4px;
            font-size: 16px;
            font-family: inherit;
        }

        input:focus, textarea:focus, select:focus, button:focus {
            outline: none;
            border-color: #3498db;
            box-shadow: 0 0 0 3px rgba(52, 152, 219, 0.2);
        }

        button {
            background: #3498db;
            color: white;
            border: 2px solid #3498db;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.2s;
        }

        button:hover {
            background: #2980b9;
            border-color: #2980b9;
        }

        .button-group {
            display: flex;
            gap: 10px;
        }

        .hidden {
            display: none;
        }

        .sr-only {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border: 0;
        }

        .keyboard-help {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            padding: 15px;
            margin-bottom: 20px;
            border-radius: 4px;
        }

        .keyboard-help h3 {
            margin-bottom: 10px;
            font-size: 16px;
        }

        .keyboard-help ul {
                        // Pass a valid origin only when served over http/https; do NOT spoof localhost when opened via file://
                        const playerVars = { playsinline: 1 };
                        if (location && location.protocol && location.protocol.startsWith('http')) {
                            playerVars.origin = location.origin;
                        }
        }

        .keyboard-help li {
            margin-bottom: 5px;
        }
                                playerVars,
        .empty-state {
            text-align: center;
            padding: 40px;
            color: #6c757d;
                                        let msg;
                                        if (code === 153) {
                                            msg = 'Embedding blocked (error 153: missing Referer / API client identity). Run this app via a local web server (http://localhost) instead of file://, and avoid extensions that strip the Referer header.';
                                        } else if (code === 101 || code === 150) {
                                            msg = 'The video owner has disabled embedding. You must open it on YouTube.';
                                        } else {
                                            msg = 'An error occurred while trying to play this video.';
                                        }

        .deck-card {
            background: #f8f9fa;
                                        fallback.innerHTML = `<p>${msg}</p>`;
            border-radius: 6px;
            padding: 20px;
            margin-bottom: 15px;
            transition: all 0.2s;
        }
                                        link.style.display = 'inline-block';
                                        link.style.marginTop = '8px';
                                        // Provide quick instructions for local hosting if 153
                                        if (code === 153) {
                                            const tips = document.createElement('details');
                                            tips.style.marginTop = '10px';
                                            const sum = document.createElement('summary');
                                            sum.textContent = 'How to fix locally';
                                            const pre = document.createElement('pre');
                                            pre.style.whiteSpace = 'pre-wrap';
                                            pre.textContent = 'Python 3:\n  python -m http.server 8000\nNode (http-server):\n  npx http-server -p 8000\nThen open: http://localhost:8000/index.html';
                                            tips.appendChild(sum);
                                            tips.appendChild(pre);
                                            fallback.appendChild(tips);
                                        }

        .deck-card:hover {
            border-color: #3498db;
            background: #e3f2fd;
        }

        .deck-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 10px;
        }

        .deck-title {
            font-size: 18px;
            font-weight: 600;
            color: #2c3e50;
        }

        .flashcard {
            background: #fff;
            border: 3px solid #3498db;
            border-radius: 8px;
            padding: 30px;
            margin: 20px 0;
            min-height: 200px;
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
            position: relative;
        }

        .flashcard-content {
            font-size: 18px;
            line-height: 1.5;
        }

        .progress {
            text-align: center;
            margin-bottom: 20px;
            font-size: 16px;
            color: #2c3e50;
        }

        .progress-bar {
            width: 100%;
            height: 20px;
            background: #ecf0f1;
            border-radius: 10px;
            overflow: hidden;
            margin: 10px 0;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #3498db, #2980b9);
            transition: width 0.3s ease;
        }

        /* Help dialog styles (scoped to #help-modal) */
        #help-modal dialog::backdrop, #help-modal::backdrop {
            /* some UAs support dialog::backdrop; keep for safety */
            background: rgba(0,0,0,0.5);
        }
        #help-modal .modal-dialog {
            width: 96vw;
            max-width: none;
            height: 92vh;
            background: #fff;
            border-radius: 8px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            border: 2px solid #3498db;
            display: flex;
            flex-direction: column;
        }
        #help-modal .modal-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 16px 20px;
            border-bottom: 1px solid #dee2e6;
        }
        #help-modal .modal-title {
            margin: 0;
            font-size: 20px;
        }
        #help-modal .modal-body {
            padding: 16px 20px 20px;
            flex: 1 1 auto;
            overflow: auto;
            text-align: center;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            gap: 8px;
        }
        #help-modal .modal-body ul,
        #help-modal .modal-body ol {
            display: inline-block;
            text-align: left;
            margin-left: 0;
        }
        #help-modal .close-btn {
            width: auto;
            padding: 8px 12px;
            background: transparent;
            color: #2c3e50;
            border: 2px solid #bdc3c7;
        }
        #help-modal .close-btn:hover {
            background: #f8f9fa;
        }

        /* Accessible generic modal */
        .modal-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.4);
            z-index: 1000;
        }

        .modal {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: min(600px, 90vw);
            background: #fff;
            border: 2px solid #3498db;
            border-radius: 8px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            z-index: 1001;
            padding: 20px;
        }

        .modal-header h2 {
            margin-bottom: 10px;
        }

        .modal-body {
            margin-bottom: 15px;
        }

        .modal-footer {
            display: flex;
            justify-content: flex-end;
            gap: 10px;
        }

        .hidden[aria-hidden="true"] { display: none; }
        .media-embed-wrapper {
            margin-top: 12px;
            width: 100%;
            max-width: 100%;
        }
        .media-embed-wrapper iframe {
            width: 100% !important;
            height: 360px !important;
            border: 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>StudyFlow</h1>
            <p>Intelligent, accessible flashcards with spaced repetition - making studying seamless and engaging for everyone.</p>
            <div class="section" style="margin-top:10px;">
                <button id="open-help-btn" type="button">Help</button>
            </div>
        </header>


        <div aria-live="polite" aria-atomic="true" class="sr-only" id="announcements"></div>

        <nav class="nav-tabs" role="tablist">
            <button class="nav-tab active" role="tab" data-tab="decks" aria-selected="true">My Decks</button>
            <button class="nav-tab" role="tab" data-tab="create">Create Deck</button>
            <button class="nav-tab" role="tab" data-tab="study">Study Mode</button>
        </nav>

        <main>
            <!-- Decks Tab -->
            <section class="tab-content active" id="decks-tab" role="tabpanel">
                <h2>Your Study Decks</h2>
                <div class="section" aria-label="Folder actions">
                    <button id="add-folder-btn" type="button">Add Folder</button>
                </div>
                <div id="decks-list">
                    <div class="empty-state">
                        <h3>Welcome to StudyFlow!</h3>
                        <p>Create your first deck to get started studying.</p>
                        <button type="button" onclick="switchTab('create')">Create Your First Deck</button>
                    </div>
                </div>
            </section>

            <!-- Create Deck Tab -->
            <section class="tab-content" id="create-tab" role="tabpanel">
                <h2>Create New Deck</h2>
                
                <div class="section">
                    <label for="deck-name">Deck Name:</label>
                    <input type="text" id="deck-name" placeholder="e.g., Biology Chapter 5">
                    
                    <label for="deck-category">Category:</label>
                    <select id="deck-category">
                        <option value="Biology">Biology</option>
                        <option value="Chemistry">Chemistry</option>
                        <option value="Physics">Physics</option>
                        <option value="Math">Math</option>
                        <option value="History">History</option>
                        <option value="Other">Other</option>
                    </select>

                    <label for="deck-folder">Folder:</label>
                    <select id="deck-folder" aria-describedby="deck-folder-help">
                        <!-- options populated by JS -->
                    </select>
                    <div id="deck-folder-help" class="sr-only">Choose a folder to save this deck into. Select "New folder…" to create one.</div>
                </div>

                <div class="section">
                    <h3>Create Cards</h3>
                    <div class="button-group">
                        <button id="auto-method-btn" type="button">Auto-Generate from Notes</button>
                        <button id="manual-method-btn" type="button">Create Manually</button>
                    </div>
                </div>

                <div id="auto-input" class="section hidden">
                    <label for="notes-input">Paste your study notes here:</label>
                    <textarea id="notes-input" rows="10" placeholder="Example:
What is photosynthesis?
Photosynthesis is the process by which plants convert light energy into chemical energy.

Definition: Mitochondria
Mitochondria are the powerhouses of the cell."></textarea>
                    <button id="generate-btn" type="button">Generate Cards from Notes</button>
                </div>

                <div id="manual-input" class="section hidden">
                    <label for="card-front">Front of card (question or term):</label>
                    <textarea id="card-front" rows="3" placeholder="Example: What is mitosis?"></textarea>
                    
                    <label for="card-back">Back of card (answer or definition):</label>
                    <textarea id="card-back" rows="4" placeholder="Example: Mitosis is the process of cell division."></textarea>
                    
                    <label for="card-media">Optional media URL (YouTube link, Google Drive, etc.)</label>
                    <input type="url" id="card-media" placeholder="https://www.youtube.com/watch?v=..." aria-describedby="card-media-help">
                    <div id="card-media-help" class="sr-only">Provide a link to a video or file. You can preview it after adding the card. Supported: YouTube (embedded). Other services will open in a viewer.</div>
                    
                    <button id="add-card-btn" type="button">Add This Card</button>
                </div>

                <div id="cards-preview" class="section hidden">
                    <h3>Cards Preview</h3>
                    <div id="preview-cards"></div>
                    <div class="button-group">
                        <button id="save-deck-btn" type="button">Save Deck</button>
                        <button id="cancel-deck-btn" type="button">Cancel</button>
                    </div>
                </div>
            </section>

            <!-- Study Mode Tab -->
            <section class="tab-content" id="study-tab" role="tabpanel">
                <div id="no-study-content">
                    <div class="empty-state">
                        <h3>No Active Study Session</h3>
                        <p>Select a deck from "My Decks" to start studying.</p>
                    </div>
                </div>

                <div id="study-mode-content" class="hidden">
                    <h2>Study Mode</h2>
                    <div class="progress" id="study-progress" aria-live="polite"></div>
                    <div class="progress-bar">
                        <div class="progress-fill" id="progress-fill" style="width: 0%"></div>
                    </div>
                    
                    <div class="flashcard" id="flashcard" tabindex="0" role="button" aria-label="Flashcard - press Space or Enter to flip">
                        <div class="flashcard-content" id="card-content">Click a deck to start studying!</div>
                    </div>

                    <div class="button-group">
                        <button id="prev-btn" type="button">Previous Card</button>
                        <button id="flip-btn" type="button">Flip Card</button>
                        <button id="next-btn" type="button">Next Card</button>
                    </div>

                    <div class="button-group">
                        <button id="end-study-btn" type="button">End Study Session</button>
                    </div>
                </div>
            </section>
        </main>
    </div>

    <!-- Help Modal (dialog) -->
    <dialog id="help-modal" aria-labelledby="help-title" aria-describedby="help-description">
        <div class="modal-dialog">
            <div class="modal-header">
                <h1 id="help-title" class="modal-title">Help</h1>
                <button id="close-help-btn" type="button" class="close-btn" aria-label="Close help">Close</button>
            </div>
            <div id="help-description" class="modal-body">
                <p>Welcome to StudyFlow. This Help covers how to navigate the app, create decks, and study efficiently with keyboard shortcuts.</p>

                <h2>Overview</h2>
                <p>StudyFlow lets you create flashcard decks, generate cards from notes, and study them with accessible controls and progress tracking.</p>

                <h2>Keyboard Navigation</h2>
                <ul>
                    <li><strong>Tab/Shift+Tab:</strong> Move between interactive elements</li>
                    <li><strong>Space/Enter:</strong> Activate buttons and flip the current card</li>
                    <li><strong>Arrow Keys:</strong> Navigate cards during study (Left/Right)</li>
                    <li><strong>?:</strong> Open Help</li>
                    <li><strong>Escape:</strong> Close dialogs or return to deck selection</li>
                </ul>

                <h2>Creating Decks</h2>
                <ol>
                    <li>Go to “Create Deck”.</li>
                    <li>Enter a deck name and pick a category.</li>
                    <li>Choose to auto-generate from your notes or create cards manually.</li>
                    <li>Preview and save when ready.</li>
                </ol>

                <h2>Studying Cards</h2>
                <ul>
                    <li>Select a deck from “My Decks”, then choose “Study This Deck”.</li>
                    <li>Use Flip to switch between front and back.</li>
                    <li>Use Previous/Next or arrow keys to move through cards.</li>
                    <li>Progress updates are announced and shown visually.</li>
                </ul>
            </div>
        </div>
    </dialog>

    <!-- Accessible generic modal elements (used for prompts/confirmations) -->
    <div id="modal-overlay" class="modal-overlay hidden" aria-hidden="true"></div>
    <div id="app-modal" class="modal hidden" role="dialog" aria-modal="true" aria-labelledby="modal-title" aria-describedby="modal-desc">
        <div class="modal-header">
            <h2 id="modal-title">Dialog</h2>
        </div>
        <div class="modal-body">
            <p id="modal-desc" class="sr-only"></p>
            <div id="modal-content"></div>
        </div>
        <div class="modal-footer button-group">
            <button id="modal-cancel-btn" type="button">Cancel</button>
            <button id="modal-confirm-btn" type="button">Confirm</button>
        </div>
    </div>

    <script>
        // Simple StudyFlow App
        class StudyFlowApp {
            constructor() {
                this.decks = this.loadDecks();
                this.folders = this.loadFolders();
                this.currentDeck = null;
                this.currentCardIndex = 0;
                this.showingFront = true;
                this.tempCards = [];
                this.creationMode = null;
                this.initializeElements();
                this.setupEventListeners();
                this.populateFolderOptions(this.deckFolder);
                this.renderDecks();
            }

            initializeElements() {
                // Navigation
                this.navTabs = document.querySelectorAll('.nav-tab');
                this.tabContents = document.querySelectorAll('.tab-content');
                
                // Create deck elements
                this.deckName = document.getElementById('deck-name');
                this.deckCategory = document.getElementById('deck-category');
                this.deckFolder = document.getElementById('deck-folder');
                this.autoMethodBtn = document.getElementById('auto-method-btn');
                this.manualMethodBtn = document.getElementById('manual-method-btn');
                this.autoInput = document.getElementById('auto-input');
                this.manualInput = document.getElementById('manual-input');
                this.notesInput = document.getElementById('notes-input');
                this.generateBtn = document.getElementById('generate-btn');
                this.cardFront = document.getElementById('card-front');
                this.cardBack = document.getElementById('card-back');
                this.cardMedia = document.getElementById('card-media');
                this.addCardBtn = document.getElementById('add-card-btn');
                this.cardsPreview = document.getElementById('cards-preview');
                this.previewCards = document.getElementById('preview-cards');
                this.saveDeckBtn = document.getElementById('save-deck-btn');
                this.cancelDeckBtn = document.getElementById('cancel-deck-btn');
                
                // Study elements
                this.studyModeContent = document.getElementById('study-mode-content');
                this.noStudyContent = document.getElementById('no-study-content');
                this.studyProgress = document.getElementById('study-progress');
                this.progressFill = document.getElementById('progress-fill');
                this.flashcard = document.getElementById('flashcard');
                this.cardContent = document.getElementById('card-content');
                this.prevBtn = document.getElementById('prev-btn');
                this.flipBtn = document.getElementById('flip-btn');
                this.nextBtn = document.getElementById('next-btn');
                this.endStudyBtn = document.getElementById('end-study-btn');
                
                // Other elements
                this.decksList = document.getElementById('decks-list');
                this.announcements = document.getElementById('announcements');

                // Help modal elements (dialog)
                this.openHelpBtn = document.getElementById('open-help-btn');
                this.helpModal = document.getElementById('help-modal');
                this.closeHelpBtn = document.getElementById('close-help-btn');
                this.mainEl = document.querySelector('main');
                this.lastFocusedBeforeHelp = null;

                // Folder and generic app modal elements
                this.addFolderBtn = document.getElementById('add-folder-btn');
                this.appContainer = document.querySelector('.container');

                // Generic modal elements (used for prompts/confirmations)
                this.modal = document.getElementById('app-modal');
                this.modalOverlay = document.getElementById('modal-overlay');
                this.modalTitle = document.getElementById('modal-title');
                this.modalDesc = document.getElementById('modal-desc');
                this.modalContent = document.getElementById('modal-content');
                this.modalCancelBtn = document.getElementById('modal-cancel-btn');
                this.modalConfirmBtn = document.getElementById('modal-confirm-btn');
                this._lastFocusedEl = null;
            }

            setupEventListeners() {
                // Navigation
                this.navTabs.forEach(tab => {
                    tab.addEventListener('click', () => {
                        const tabName = tab.dataset.tab;
                        this.switchTab(tabName);
                    });
                });

                // Create deck
                this.autoMethodBtn.addEventListener('click', () => this.setCreationMode('auto'));
                this.manualMethodBtn.addEventListener('click', () => this.setCreationMode('manual'));
                this.generateBtn.addEventListener('click', () => this.generateCards());
                this.addCardBtn.addEventListener('click', () => this.addManualCard());
                this.saveDeckBtn.addEventListener('click', () => this.saveDeck());
                this.cancelDeckBtn.addEventListener('click', () => this.cancelDeck());
                this.deckFolder.addEventListener('change', (e) => this.onDeckFolderSelectChanged(e));

                // Study mode
                this.flipBtn.addEventListener('click', () => this.flipCard());
                // Only flip the card when clicking on the card background/text.
                // Ignore clicks that originate from interactive elements (buttons, links, iframes, inputs, media areas)
                this.flashcard.addEventListener('click', (e) => {
                    try {
                        const ignored = e.target && e.target.closest && e.target.closest('button, a, iframe, input, textarea, select, .media-embed-wrapper, .media-embed-content, .yt-player-container');
                        if (ignored) return;
                    } catch (_) {}
                    this.flipCard();
                });
                this.flashcard.addEventListener('keydown', (e) => {
                    if (e.key === ' ' || e.key === 'Enter') {
                        e.preventDefault();
                        this.flipCard();
                    }
                });
                this.prevBtn.addEventListener('click', () => this.previousCard());
                this.nextBtn.addEventListener('click', () => this.nextCard());
                this.endStudyBtn.addEventListener('click', () => this.endStudy());

                // Keyboard shortcuts
                document.addEventListener('keydown', (e) => {
                    // Global Help shortcut (Shift + / => ?)
                    const tag = (e.target && e.target.tagName ? e.target.tagName.toLowerCase() : '');
                    if ((e.key === '?' || (e.shiftKey && e.key === '/')) && !['input','textarea','select'].includes(tag)) {
                        e.preventDefault();
                        this.openHelpModal();
                        return;
                    }

                    if (this.currentDeck) {
                        switch(e.key) {
                            case 'ArrowLeft':
                                e.preventDefault();
                                this.previousCard();
                                break;
                            case 'ArrowRight':
                                e.preventDefault();
                                this.nextCard();
                                break;
                            case 'Escape':
                                e.preventDefault();
                                if (this.isHelpOpen()) {
                                    this.closeHelpModal();
                                } else {
                                    this.endStudy();
                                }
                                break;
                        }
                    }
                });

                // Help modal events
                if (this.openHelpBtn) this.openHelpBtn.addEventListener('click', () => this.openHelpModal());
                if (this.closeHelpBtn) this.closeHelpBtn.addEventListener('click', () => this.closeHelpModal());
                if (this.helpModal) this.helpModal.addEventListener('close', () => this.closeHelpModal(true));

                // Trap focus within help dialog and handle Escape when it's open
                document.addEventListener('keydown', (e) => {
                    if (!this.isHelpOpen()) return;
                    if (e.key === 'Tab') this.trapFocus(e);
                    if (e.key === 'Escape') {
                        e.preventDefault();
                        this.closeHelpModal();
                    }
                });

                // Folder actions
                if (this.addFolderBtn) {
                    this.addFolderBtn.addEventListener('click', () => this.promptAddFolder());
                }
            }

            announce(message) {
                this.announcements.textContent = message;
                setTimeout(() => {
                    this.announcements.textContent = '';
                }, 1000);
            }

            switchTab(tabName) {
                // Update nav tabs
                this.navTabs.forEach(tab => {
                    tab.classList.remove('active');
                    tab.setAttribute('aria-selected', 'false');
                });
                document.querySelector(`[data-tab="${tabName}"]`).classList.add('active');
                document.querySelector(`[data-tab="${tabName}"]`).setAttribute('aria-selected', 'true');

                // Update tab content
                this.tabContents.forEach(content => content.classList.remove('active'));
                document.getElementById(`${tabName}-tab`).classList.add('active');

                this.announce(`Switched to ${tabName} tab`);
            }

            loadDecks() {
                try {
                    const saved = localStorage.getItem('studyflow-decks');
                    return saved ? JSON.parse(saved) : [];
                } catch (error) {
                    console.warn('Could not load decks:', error);
                    return [];
                }
            }

            saveDecks() {
                try {
                    localStorage.setItem('studyflow-decks', JSON.stringify(this.decks));
                    return true;
                } catch (error) {
                    console.warn('Could not save decks:', error);
                    return false;
                }
            }

            // Folder persistence
            loadFolders() {
                try {
                    const saved = localStorage.getItem('studyflow-folders');
                    const folders = saved ? JSON.parse(saved) : [];
                    return Array.isArray(folders) ? folders : [];
                } catch (error) {
                    console.warn('Could not load folders:', error);
                    return [];
                }
            }

            saveFolders() {
                try {
                    localStorage.setItem('studyflow-folders', JSON.stringify(this.folders));
                    return true;
                } catch (error) {
                    console.warn('Could not save folders:', error);
                    return false;
                }
            }

            generateFolderId() {
                return 'f_' + Date.now().toString(36) + '_' + Math.random().toString(36).slice(2, 8);
            }

            populateFolderOptions(selectEl, selectedId = '') {
                if (!selectEl) return;
                // Remember previous selection if not provided
                const current = selectedId !== undefined && selectedId !== null ? selectedId : (selectEl.value || '');
                selectEl.innerHTML = '';
                const optNone = document.createElement('option');
                optNone.value = '';
                optNone.textContent = '(No folder)';
                selectEl.appendChild(optNone);

                // Sort folders A-Z
                const foldersSorted = [...this.folders].sort((a, b) => a.name.localeCompare(b.name));
                foldersSorted.forEach(f => {
                    const opt = document.createElement('option');
                    opt.value = f.id;
                    opt.textContent = f.name;
                    selectEl.appendChild(opt);
                });

                const optNew = document.createElement('option');
                optNew.value = '__NEW__';
                optNew.textContent = 'New folder…';
                selectEl.appendChild(optNew);

                // Restore selection
                selectEl.value = current;
                if (selectEl.value !== current) {
                    // If previous selection no longer exists, fallback to none
                    selectEl.value = '';
                }
            }

            onDeckFolderSelectChanged(e) {
                if (e.target.value === '__NEW__') {
                    this.promptAddFolder({ focusSelectAfter: true, applyToSelect: e.target });
                }
            }

            async promptAddFolder({ focusSelectAfter = false, applyToSelect = null } = {}) {
                const name = await this.openTextModal({
                    title: 'Create folder',
                    label: 'Folder name',
                    confirmText: 'Create',
                });
                if (!name || !name.trim()) {
                    if (applyToSelect) applyToSelect.value = '';
                    return;
                }
                const finalName = name.trim();
                // Prevent duplicate (case-insensitive)
                const dup = this.folders.find(f => f.name.toLowerCase() === finalName.toLowerCase());
                if (dup) {
                    this.announce(`A folder named "${finalName}" already exists.`);
                    if (applyToSelect) {
                        applyToSelect.value = dup.id;
                    }
                    return;
                }
                const folder = { id: this.generateFolderId(), name: finalName, created: new Date().toISOString() };
                this.folders.push(folder);
                if (this.saveFolders()) {
                    this.announce(`Folder "${finalName}" created.`);
                    this.populateFolderOptions(this.deckFolder, folder.id);
                    this.renderDecks();
                    if (applyToSelect) {
                        this.populateFolderOptions(applyToSelect, folder.id);
                        applyToSelect.value = folder.id;
                    }
                    if (focusSelectAfter) (applyToSelect || this.deckFolder).focus();
                } else {
                    this.announce('Error saving folder. Please try again.');
                }
            }

            async renameFolder(folderId) {
                const folder = this.folders.find(f => f.id === folderId);
                if (!folder) return;
                const newName = await this.openTextModal({
                    title: 'Rename folder',
                    label: 'Folder name',
                    initialValue: folder.name,
                    confirmText: 'Rename',
                });
                if (!newName || !newName.trim()) return;
                const finalName = newName.trim();
                const dup = this.folders.find(f => f.id !== folderId && f.name.toLowerCase() === finalName.toLowerCase());
                if (dup) {
                    this.announce(`A folder named "${finalName}" already exists.`);
                    return;
                }
                folder.name = finalName;
                if (this.saveFolders()) {
                    this.populateFolderOptions(this.deckFolder, this.deckFolder.value);
                    this.renderDecks();
                    this.announce('Folder renamed.');
                }
            }

            async deleteFolder(folderId) {
                const folder = this.folders.find(f => f.id === folderId);
                if (!folder) return;
                const confirmDelete = await this.openConfirmModal({
                    title: 'Delete folder',
                    message: `Delete folder "${folder.name}"? Decks will be moved to (No folder).`,
                    confirmText: 'Delete',
                });
                if (!confirmDelete) return;
                // Move decks to no folder
                this.decks.forEach(d => {
                    if (d.folderId === folderId) d.folderId = null;
                });
                // Remove folder
                this.folders = this.folders.filter(f => f.id !== folderId);
                this.saveFolders();
                this.saveDecks();
                this.populateFolderOptions(this.deckFolder, this.deckFolder.value === folderId ? '' : this.deckFolder.value);
                this.renderDecks();
                this.announce('Folder deleted and decks moved to (No folder).');
            }

            renderDecks() {
                // Empty state
                if (this.decks.length === 0) {
                    this.decksList.innerHTML = `
                        <div class="empty-state">
                            <h3>Welcome to StudyFlow!</h3>
                            <p>Create your first deck to get started studying.</p>
                            <button type="button" onclick="app.switchTab('create')">Create Your First Deck</button>
                        </div>
                    `;
                    return;
                }

                this.decksList.innerHTML = '';

                // Group decks by folderId
                const groups = new Map(); // folderId (or null) -> array of deck indices
                this.decks.forEach((deck, idx) => {
                    const key = deck.folderId || null;
                    if (!groups.has(key)) groups.set(key, []);
                    groups.get(key).push(idx);
                });

                // Sort folders by name; ensure (No folder) first
                const foldersSorted = [...this.folders].sort((a, b) => a.name.localeCompare(b.name));
                const orderedKeys = [null, ...foldersSorted.map(f => f.id)].filter(k => groups.has(k));

                orderedKeys.forEach(key => {
                    const isUnfiled = key === null;
                    const name = isUnfiled ? '(No folder)' : (this.folders.find(f => f.id === key)?.name || '(Unknown)');
                    const section = document.createElement('section');
                    const headingId = `folder-${key || 'none'}`;
                    section.className = 'folder-group';
                    section.setAttribute('aria-labelledby', headingId);
                    section.innerHTML = `
                        <div class="deck-header">
                            <h3 id="${headingId}" class="deck-title">${name}</h3>
                            ${isUnfiled ? '' : `
                                <div class="button-group" style="width:auto;">
                                    <button type="button" onclick="app.renameFolder('${key}')">Rename</button>
                                    <button type="button" onclick="app.deleteFolder('${key}')">Delete</button>
                                </div>
                            `}
                        </div>
                    `;

                    const idxs = groups.get(key);
                    idxs.forEach(deckIndex => {
                        const deck = this.decks[deckIndex];
                        const deckEl = document.createElement('div');
                        deckEl.className = 'deck-card';
                        const moveSelectId = `move-folder-${deckIndex}`;
                        deckEl.innerHTML = `
                            <div class="deck-header">
                                <h3 class="deck-title">${deck.name}</h3>
                            </div>
                            <p>${deck.cards.length} cards • ${deck.category}</p>
                            <div class="section" style="margin-top:10px;">
                                <label for="${moveSelectId}">Move to folder:</label>
                                <select id="${moveSelectId}" data-deck-index="${deckIndex}" aria-label="Move deck ${deck.name} to folder">
                                </select>
                            </div>
                            <div class="button-group" style="margin-top: 15px;">
                                <button type="button" onclick="app.startStudy(${deckIndex})">Study This Deck</button>
                                <button type="button" onclick="app.deleteDeck(${deckIndex})">Delete</button>
                            </div>
                        `;
                        section.appendChild(deckEl);

                        // Populate move select
                        const selectEl = deckEl.querySelector(`#${moveSelectId}`);
                        this.populateFolderOptions(selectEl, deck.folderId || '');
                        selectEl.addEventListener('change', (ev) => this.onMoveDeckFolderChanged(ev));
                    });

                    this.decksList.appendChild(section);
                });
            }

            setCreationMode(mode) {
                this.creationMode = mode;
                this.autoInput.classList.toggle('hidden', mode !== 'auto');
                this.manualInput.classList.toggle('hidden', mode !== 'manual');
                
                if (mode === 'auto') {
                    this.notesInput.focus();
                    this.announce('Auto-generate mode selected. Paste your notes.');
                } else {
                    this.cardFront.focus();
                    this.announce('Manual mode selected. Create cards one at a time.');
                }
            }

            generateCards() {
                const notes = this.notesInput.value.trim();
                if (!notes) {
                    this.announce('Please paste your study notes first.');
                    this.notesInput.focus();
                    return;
                }

                this.tempCards = this.parseNotes(notes);
                
                if (this.tempCards.length === 0) {
                    this.announce('No flashcards could be generated. Please check your notes format.');
                    return;
                }

                this.showPreview();
                this.announce(`Successfully generated ${this.tempCards.length} flashcards.`);
            }

            parseNotes(notes) {
                const cards = [];
                const lines = notes.split('\n').map(line => line.trim()).filter(line => line);
                
                for (let i = 0; i < lines.length; i++) {
                    const line = lines[i];
                    
                    // Pattern: Questions followed by answers
                    if (line.includes('?') && i + 1 < lines.length) {
                        const question = line;
                        const answer = lines[i + 1];
                        if (!answer.includes('?')) {
                            cards.push({ front: question, back: answer });
                            i++; // Skip the answer line
                        }
                    }
                    
                    // Pattern: Definition: Term
                    else if (line.toLowerCase().startsWith('definition:')) {
                        const term = line.substring(11).trim();
                        if (i + 1 < lines.length) {
                            const definition = lines[i + 1];
                            cards.push({ front: `What is ${term}?`, back: definition });
                            i++; // Skip the definition line
                        }
                    }
                    
                    // Pattern: Term: Definition
                    else if (line.includes(':') && !line.includes('?')) {
                        const parts = line.split(':');
                        if (parts.length >= 2) {
                            const term = parts[0].trim();
                            const definition = parts.slice(1).join(':').trim();
                            if (definition.length > 10) {
                                cards.push({ front: `What is ${term}?`, back: definition });
                            }
                        }
                    }
                }
                
                return cards;
            }

            addManualCard() {
                const front = this.cardFront.value.trim();
                const back = this.cardBack.value.trim();
                const media = this.cardMedia ? this.cardMedia.value.trim() : '';
                if (!front || !back) {
                    this.announce('Please fill in both the front and back of the card.');
                    if (!front) this.cardFront.focus();
                    else this.cardBack.focus();
                    return;
                }

                this.tempCards.push({ front, back, mediaUrl: media || null });

                // Clear the form
                this.cardFront.value = '';
                this.cardBack.value = '';
                if (this.cardMedia) this.cardMedia.value = '';

                this.showPreview();
                this.announce(`Card added. You now have ${this.tempCards.length} cards.`);
                this.cardFront.focus();
            }

            showPreview() {
                this.previewCards.innerHTML = '';
                this.tempCards.forEach((card, index) => {
                    const cardElement = document.createElement('div');
                    cardElement.className = 'deck-card';
                    cardElement.innerHTML = `
                        <div class="deck-header">
                            <span>Card ${index + 1}</span>
                            <button type="button" onclick="app.removeCard(${index})">Remove</button>
                        </div>
                        <p><strong>Front:</strong> ${card.front}</p>
                        <p><strong>Back:</strong> ${card.back}</p>
                    `;
                    if (card.mediaUrl) {
                        const previewBtn = document.createElement('button');
                        previewBtn.type = 'button';
                        previewBtn.textContent = 'Preview media';
                        previewBtn.addEventListener('click', () => this.openMediaViewer(card.mediaUrl, `Card ${index + 1} media`));
                        cardElement.appendChild(previewBtn);
                    }
                    this.previewCards.appendChild(cardElement);
                });
                
                this.cardsPreview.classList.remove('hidden');
            }

            removeCard(index) {
                this.tempCards.splice(index, 1);
                if (this.tempCards.length === 0) {
                    this.cardsPreview.classList.add('hidden');
                } else {
                    this.showPreview();
                }
                this.announce(`Card removed. ${this.tempCards.length} cards remaining.`);
            }

            saveDeck() {
                const name = this.deckName.value.trim();
                const category = this.deckCategory.value;
                const folderId = this.deckFolder.value || null;
                
                if (!name) {
                    this.announce('Please enter a deck name.');
                    this.deckName.focus();
                    return;
                }
                
                if (this.tempCards.length === 0) {
                    this.announce('Please create at least one card before saving.');
                    return;
                }
                
                const deck = {
                    name,
                    category,
                    folderId,
                    cards: this.tempCards,
                    created: new Date().toISOString()
                };
                
                this.decks.push(deck);
                if (this.saveDecks()) {
                    this.announce(`Deck "${name}" saved successfully with ${this.tempCards.length} cards.`);
                    // Refresh decks list so the new deck appears immediately
                    this.renderDecks();
                    this.resetCreateForm();
                    this.switchTab('decks');
                } else {
                    this.announce('Error saving deck. Please try again.');
                }
            }

            async cancelDeck() {
                if (this.tempCards.length > 0) {
                    const ok = await this.openConfirmModal({
                        title: 'Discard deck?',
                        message: 'Are you sure you want to cancel? All unsaved cards will be lost.',
                        confirmText: 'Discard',
                    });
                    if (!ok) return;
                }
                this.resetCreateForm();
                this.switchTab('decks');
            }

            resetCreateForm() {
                this.deckName.value = '';
                this.deckCategory.value = 'Biology';
                this.notesInput.value = '';
                this.cardFront.value = '';
                this.cardBack.value = '';
                this.tempCards = [];
                this.creationMode = null;
                this.autoInput.classList.add('hidden');
                this.manualInput.classList.add('hidden');
                this.cardsPreview.classList.add('hidden');
                this.populateFolderOptions(this.deckFolder);
                this.deckFolder.value = '';
            }

            async deleteDeck(index) {
                const deck = this.decks[index];
                const ok = await this.openConfirmModal({
                    title: 'Delete deck',
                    message: `Are you sure you want to delete "${deck.name}"?`,
                    confirmText: 'Delete',
                });
                if (!ok) return;
                this.decks.splice(index, 1);
                this.saveDecks();
                this.renderDecks();
                this.announce(`Deck "${deck.name}" deleted.`);
            }

            onMoveDeckFolderChanged(e) {
                const target = e.target;
                const deckIndex = Number(target.getAttribute('data-deck-index'));
                if (target.value === '__NEW__') {
                    this.promptAddFolder({ focusSelectAfter: true, applyToSelect: target });
                    return;
                }
                const newFolderId = target.value || null;
                const deck = this.decks[deckIndex];
                deck.folderId = newFolderId;
                this.saveDecks();
                // Re-render to move deck into the correct group
                this.renderDecks();
                const folderName = newFolderId ? (this.folders.find(f => f.id === newFolderId)?.name || '(Unknown)') : '(No folder)';
                this.announce(`Moved deck "${deck.name}" to folder ${folderName}.`);
            }

            startStudy(deckIndex) {
                this.currentDeck = this.decks[deckIndex];
                this.currentCardIndex = 0;
                this.showingFront = true;
                
                this.switchTab('study');
                this.studyModeContent.classList.remove('hidden');
                this.noStudyContent.classList.add('hidden');
                
                this.displayCurrentCard();
                this.announce(`Started studying "${this.currentDeck.name}" with ${this.currentDeck.cards.length} cards.`);
                this.flashcard.focus();
            }

            displayCurrentCard() {
                if (!this.currentDeck || !this.currentDeck.cards.length) return;
                
                const card = this.currentDeck.cards[this.currentCardIndex];
                const progress = Math.round(((this.currentCardIndex + 1) / this.currentDeck.cards.length) * 100);
                
                this.studyProgress.textContent = `Card ${this.currentCardIndex + 1} of ${this.currentDeck.cards.length}`;
                this.progressFill.style.width = `${progress}%`;
                
                const content = this.showingFront ? card.front : card.back;
                const side = this.showingFront ? 'front' : 'back';

                // Clear previous content then set text
                this.cardContent.textContent = '';
                const textNode = document.createElement('div');
                textNode.textContent = content;
                this.cardContent.appendChild(textNode);

                // If showing back and card has media, render embed below the text
                const existingMedia = this.cardContent.querySelector('.media-embed-wrapper');
                if (existingMedia) existingMedia.remove();
                if (!this.showingFront && card.mediaUrl) {
                    const mediaWrapper = document.createElement('div');
                    mediaWrapper.className = 'media-embed-wrapper';
                    mediaWrapper.setAttribute('aria-live', 'polite');

                    // Accessible toggle so users can hide/show media if they prefer
                    const toggleBtn = document.createElement('button');
                    toggleBtn.type = 'button';
                    toggleBtn.className = 'media-toggle-btn';
                    toggleBtn.setAttribute('aria-controls', `media-content-${this.currentCardIndex}`);
                    toggleBtn.setAttribute('aria-expanded', 'true');
                    toggleBtn.textContent = 'Hide media';

                    const mediaContent = document.createElement('div');
                    mediaContent.id = `media-content-${this.currentCardIndex}`;
                    mediaContent.className = 'media-embed-content';
                    mediaContent.style.display = 'block';
                    // Expose as a region and allow programmatic focus for assistive tech
                    mediaContent.setAttribute('role', 'region');
                    mediaContent.setAttribute('aria-label', `${this.currentDeck && this.currentDeck.name ? this.currentDeck.name : 'Card'} media`);
                    mediaContent.tabIndex = -1;

                    const embed = this.createMediaEmbed(card.mediaUrl, `${this.currentDeck.name} - Card ${this.currentCardIndex + 1}`);
                    mediaContent.appendChild(embed);

                    // Stop propagation so clicks on these controls don't flip the parent flashcard
                    toggleBtn.addEventListener('click', (evt) => {
                        evt.stopPropagation();
                        const expanded = toggleBtn.getAttribute('aria-expanded') === 'true';
                        toggleBtn.setAttribute('aria-expanded', String(!expanded));
                        const nowShown = expanded ? false : true;
                        mediaContent.style.display = nowShown ? 'block' : 'none';
                        toggleBtn.textContent = nowShown ? 'Hide media' : 'Show media';

                        // When showing the media, move focus inside the media region so screen readers and keyboard users
                        // can discover and interact with the player. If an iframe exists, make it focusable first.
                        if (nowShown) {
                            const focusFirst = () => {
                                const first = mediaContent.querySelector('iframe, a, button, [tabindex]');
                                if (first) {
                                    if (first.tagName && first.tagName.toLowerCase() === 'iframe') first.setAttribute('tabindex', '0');
                                    try { first.focus(); } catch (_) { mediaContent.focus(); }
                                } else {
                                    try { mediaContent.focus(); } catch (_) {}
                                }
                            };
                            setTimeout(focusFirst, 250);
                        } else {
                            try { toggleBtn.focus(); } catch(_) {}
                        }

                        // Announce the change for assistive tech
                        try { this.announce(nowShown ? 'Media shown.' : 'Media hidden.'); } catch (e) {}
                    });

                    // Prevent clicks inside the media area (including the iframe) from bubbling up to
                    // the flashcard so users can interact with the player.
                    mediaContent.addEventListener('click', (evt) => { evt.stopPropagation(); });

                    // Make toggle explicitly focusable and append toggle and media area
                    toggleBtn.tabIndex = 0;
                    mediaWrapper.appendChild(toggleBtn);
                    mediaWrapper.appendChild(mediaContent);
                    this.cardContent.appendChild(mediaWrapper);

                    // If we've just flipped to the back with media visible, move focus to the toggle
                    // so NVDA/keyboard users can interact with the media immediately.
                    if (!this.showingFront) {
                        setTimeout(() => {
                            try { toggleBtn.focus(); } catch (_) {}
                        }, 50);
                    }
                }
                this.flashcard.setAttribute('aria-label', 
                    `Card ${this.currentCardIndex + 1} of ${this.currentDeck.cards.length}, showing ${side}. ${content}. Press Space or Enter to flip.`
                );
                
                // Update navigation buttons
                this.prevBtn.disabled = this.currentCardIndex === 0;
                this.nextBtn.disabled = this.currentCardIndex === this.currentDeck.cards.length - 1;
            }

            flipCard() {
                if (!this.currentDeck) return;
                
                this.showingFront = !this.showingFront;
                this.displayCurrentCard();
                
                const side = this.showingFront ? 'front' : 'back';
                const content = this.currentDeck.cards[this.currentCardIndex][this.showingFront ? 'front' : 'back'];
                this.announce(`Flipped to ${side}: ${content}`);
            }

            previousCard() {
                if (this.currentCardIndex > 0) {
                    this.currentCardIndex--;
                    this.showingFront = true;
                    this.displayCurrentCard();
                    this.announce(`Previous card: ${this.currentDeck.cards[this.currentCardIndex].front}`);
                }
            }

            nextCard() {
                if (this.currentCardIndex < this.currentDeck.cards.length - 1) {
                    this.currentCardIndex++;
                    this.showingFront = true;
                    this.displayCurrentCard();
                    this.announce(`Next card: ${this.currentDeck.cards[this.currentCardIndex].front}`);
                } else {
                    this.announce('You have reached the end of the flashcards. Great job!');
                }
            }

            endStudy() {
                this.currentDeck = null;
                this.switchTab('decks');
                this.studyModeContent.classList.add('hidden');
                this.noStudyContent.classList.remove('hidden');
                this.announce('Study session ended.');
            }

            // ===== Help Modal =====
            isHelpOpen() {
                return this.helpModal && this.helpModal.open === true;
            }

            getFocusableElementsInModal() {
                if (!this.helpModal) return [];
                const selectors = [
                    'a[href]',
                    'area[href]',
                    'button:not([disabled])',
                    'input:not([disabled])',
                    'select:not([disabled])',
                    'textarea:not([disabled])',
                    '[tabindex]:not([tabindex="-1"])'
                ];
                return Array.from(this.helpModal.querySelectorAll(selectors.join(',')))
                    .filter(el => el.offsetParent !== null || el === document.activeElement);
            }

            openHelpModal() {
                if (!this.helpModal || this.isHelpOpen()) return;
                this.lastFocusedBeforeHelp = document.activeElement;

                // Show dialog
                try { this.helpModal.showModal(); } catch (_) { this.helpModal.show(); }
                this.helpModal.setAttribute('aria-hidden', 'false');

                // Lock page scroll
                document.body.style.overflow = 'hidden';

                // Focus management
                const dialog = this.helpModal.querySelector('.modal-dialog');
                if (dialog) dialog.focus();
                const focusables = this.getFocusableElementsInModal();
                if (focusables.length) focusables[0].focus();

                this.announce('Help opened.');
            }

            closeHelpModal() {
                if (!this.helpModal || !this.isHelpOpen()) return;
                // Close dialog if initiated by JS
                if (!arguments[0]) {
                    try { this.helpModal.close(); } catch (_) {}
                }
                this.helpModal.setAttribute('aria-hidden', 'true');

                // Background unlock handled by UA; still restore overflow

                // Restore page scroll
                document.body.style.overflow = '';

                // Restore focus
                if (this.lastFocusedBeforeHelp && typeof this.lastFocusedBeforeHelp.focus === 'function') {
                    this.lastFocusedBeforeHelp.focus();
                } else if (this.openHelpBtn) {
                    this.openHelpBtn.focus();
                }

                this.announce('Help closed.');
            }

            trapFocus(e) {
                const focusables = this.getFocusableElementsInModal();
                if (!focusables.length) return;
                const first = focusables[0];
                const last = focusables[focusables.length - 1];
                const active = document.activeElement;

                if (e.shiftKey) {
                    if (active === first || !this.helpModal.contains(active)) {
                        e.preventDefault();
                        last.focus();
                    }
                } else {
                    if (active === last) {
                        e.preventDefault();
                        first.focus();
                    }
                }
            }
        }

        // Global functions for onclick events
        function switchTab(tabName) {
            app.switchTab(tabName);
        }

        // Initialize the app
        let app;
        document.addEventListener('DOMContentLoaded', () => {
            app = new StudyFlowApp();
            // Warn user early if running from file:// which can trigger YouTube error 153
            try { app.checkEmbeddingEnvironment(); } catch (_) {}
        });

        // Modal helpers added to StudyFlowApp prototype
        StudyFlowApp.prototype.openTextModal = function({ title, label, initialValue = '', confirmText = 'Save', cancelText = 'Cancel' }) {
            return new Promise((resolve) => {
                const inputId = 'modal-text-input';
                this.modalTitle.textContent = title;
                this.modalDesc.textContent = `${label} input dialog.`;
                this.modalContent.innerHTML = `
                    <label for="${inputId}">${label}:</label>
                    <input type="text" id="${inputId}" value="${initialValue.replace(/\"/g, '&quot;')}">
                `;
                this.modalConfirmBtn.textContent = confirmText;
                this.modalCancelBtn.textContent = cancelText;

                const inputEl = this.modalContent.querySelector(`#${inputId}`);
                const removeInputListener = () => inputEl.removeEventListener('input', updateConfirmState);
                const cleanup = this._openModalCommon({
                    initialFocus: inputEl,
                    onConfirm: () => { removeInputListener(); cleanup(); resolve(inputEl.value); },
                    onCancel: () => { removeInputListener(); cleanup(); resolve(null); },
                });

                const updateConfirmState = () => {
                    const hasText = inputEl.value.trim().length > 0;
                    this.modalConfirmBtn.disabled = !hasText;
                };
                inputEl.addEventListener('input', updateConfirmState);
                updateConfirmState();

                // Select text for quick editing
                setTimeout(() => { inputEl.select(); }, 0);
            });
        };

        StudyFlowApp.prototype.openConfirmModal = function({ title, message, confirmText = 'OK', cancelText = 'Cancel' }) {
            return new Promise((resolve) => {
                this.modalTitle.textContent = title;
                this.modalDesc.textContent = message;
                this.modalContent.innerHTML = `<p>${message}</p>`;
                this.modalConfirmBtn.textContent = confirmText;
                this.modalCancelBtn.textContent = cancelText;
                this._openModalCommon({
                    initialFocus: this.modalConfirmBtn,
                    onConfirm: () => resolve(true),
                    onCancel: () => resolve(false),
                });
            });
        };

        // Internal modal open/close with focus trap
        StudyFlowApp.prototype._openModalCommon = function({ initialFocus, onConfirm, onCancel }) {
            // Save last focused element
            this._lastFocusedEl = document.activeElement;
            // Show modal
            this.modal.classList.remove('hidden');
            this.modalOverlay.classList.remove('hidden');
            this.modalOverlay.setAttribute('aria-hidden', 'false');
            // Hide main for AT
            if (this.appContainer) this.appContainer.setAttribute('aria-hidden', 'true');

            // Focus management
            const focusable = () => Array.from(this.modal.querySelectorAll('button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])')).filter(el => !el.disabled && el.offsetParent !== null);
            const keyHandler = (e) => {
                if (e.key === 'Escape') {
                    e.preventDefault();
                    doCancel();
                } else if (e.key === 'Tab') {
                    const els = focusable();
                    if (els.length === 0) return;
                    const first = els[0];
                    const last = els[els.length - 1];
                    if (e.shiftKey && document.activeElement === first) {
                        e.preventDefault();
                        last.focus();
                    } else if (!e.shiftKey && document.activeElement === last) {
                        e.preventDefault();
                        first.focus();
                    }
                }
            };
            document.addEventListener('keydown', keyHandler);

            const doConfirm = () => { this._restoreModalClose(); onConfirm && onConfirm(); };
            const doCancel = () => { this._restoreModalClose(); onCancel && onCancel(); };
            const clickOutside = (e) => { if (e.target === this.modalOverlay) doCancel(); };
            this.modalConfirmBtn.onclick = doConfirm;
            this.modalCancelBtn.onclick = doCancel;
            this.modalOverlay.addEventListener('click', clickOutside);

            // Set initial focus
            (initialFocus || this.modalConfirmBtn).focus();

            // Return cleanup handler to remove listeners when closing
            return () => {
                document.removeEventListener('keydown', keyHandler);
                this.modalOverlay.removeEventListener('click', clickOutside);
                this.modalConfirmBtn.onclick = null;
                this.modalCancelBtn.onclick = null;
            };
        };

        StudyFlowApp.prototype._restoreModalClose = function() {
            // Hide modal
            this.modal.classList.add('hidden');
            this.modalOverlay.classList.add('hidden');
            this.modalOverlay.setAttribute('aria-hidden', 'true');
            if (this.appContainer) this.appContainer.removeAttribute('aria-hidden');
            // Restore focus
            if (this._lastFocusedEl && typeof this._lastFocusedEl.focus === 'function') {
                this._lastFocusedEl.focus();
            }
        };

        // For backward compatibility
        StudyFlowApp.prototype._closeModal = function() {
            this._restoreModalClose();
        };

        // Media helpers (embedded videos/viewer) with YouTube IFrame API and error handling
        StudyFlowApp.prototype._ensureYouTubeAPI = function() {
            if (window.YT && window.YT.Player) return Promise.resolve(window.YT);
            if (this._ytPromise) return this._ytPromise;
            this._ytPromise = new Promise((resolve) => {
                const previous = window.onYouTubeIframeAPIReady;
                window.onYouTubeIframeAPIReady = function() {
                    if (typeof previous === 'function') previous();
                    resolve(window.YT);
                };
                const tag = document.createElement('script');
                tag.src = 'https://www.youtube.com/iframe_api';
                tag.async = true;
                document.head.appendChild(tag);
            });
            return this._ytPromise;
        };

        StudyFlowApp.prototype.createMediaEmbed = function(url, title = '') {
            try {
                const u = new URL(url);
                // YouTube long form
                if (u.hostname.includes('youtube.com') && u.searchParams.get('v')) {
                    const vid = u.searchParams.get('v');
                    const container = document.createElement('div');
                    container.className = 'yt-player-container';
                    const playerId = `yt-player-${Date.now().toString(36)}-${Math.random().toString(36).slice(2,8)}`;
                    const placeholder = document.createElement('div');
                    placeholder.id = playerId;
                    placeholder.setAttribute('role', 'region');
                    placeholder.setAttribute('aria-label', title || 'Video player');
                    // Make placeholder programmatically focusable so screen readers/keyboard users can reach it
                    placeholder.tabIndex = 0;
                    placeholder.style.width = '100%';
                    placeholder.style.height = '360px';
                    container.appendChild(placeholder);

                    // Create player asynchronously; capture `this`
                    const self = this;
                    this._ensureYouTubeAPI().then((YT) => {
                        const playerVars = { playsinline: 1 };
                        if (location && location.protocol && location.protocol.startsWith('http')) {
                            playerVars.origin = location.origin; // only set when valid
                        }
                        try {
                            new YT.Player(playerId, {
                                height: '360',
                                width: '100%',
                                videoId: vid,
                                playerVars,
                                events: {
                                    onError: function(event) {
                                        const code = event && event.data;
                                        let msg;
                                        if (code === 153) {
                                            msg = 'Embedding blocked (error 153: missing Referer / client identity). Serve this app via http://localhost instead of file:// and disable any extension that strips the Referer header.';
                                        } else if (code === 101 || code === 150) {
                                            msg = 'Embedding disabled by the video owner.';
                                        } else {
                                            msg = 'An error occurred while playing this video.';
                                        }
                                        const fallback = document.createElement('div');
                                        fallback.className = 'media-embed-fallback';
                                        fallback.innerHTML = `<p>${msg}</p>`;
                                        const link = document.createElement('a');
                                        link.href = url;
                                        link.target = '_blank';
                                        link.rel = 'noopener noreferrer';
                                        link.textContent = 'Open on YouTube';
                                        link.style.display = 'inline-block';
                                        link.style.marginTop = '8px';
                                        if (code === 153) {
                                            const details = document.createElement('details');
                                            details.style.marginTop = '10px';
                                            const summary = document.createElement('summary');
                                            summary.textContent = 'Local server instructions';
                                            const pre = document.createElement('pre');
                                            pre.style.whiteSpace = 'pre-wrap';
                                            pre.textContent = 'Python 3:\n  python -m http.server 8000\nNode (http-server):\n  npx http-server -p 8000\nThen open: http://localhost:8000/index.html';
                                            details.appendChild(summary);
                                            details.appendChild(pre);
                                            fallback.appendChild(details);
                                        }
                                        fallback.appendChild(link);
                                        placeholder.replaceWith(fallback);
                                        try { self.announce('Media embed failed; fallback shown.'); } catch(e) {}
                                    }
                                }
                            });
                        } catch (e) {
                            const fallback = document.createElement('div');
                            fallback.className = 'media-embed-fallback';
                            fallback.innerHTML = `<p>Unable to initialize video player.</p>`;
                            const link = document.createElement('a');
                            link.href = url;
                            link.target = '_blank';
                            link.rel = 'noopener noreferrer';
                            link.textContent = 'Open on YouTube';
                            fallback.appendChild(link);
                            placeholder.replaceWith(fallback);
                        }
                    }).catch(() => {
                        // Could not load API: show fallback
                        const fallback = document.createElement('div');
                        fallback.className = 'media-embed-fallback';
                        fallback.innerHTML = `<p>Unable to load video player. Open on YouTube.</p>`;
                        const link = document.createElement('a');
                        link.href = url;
                        link.target = '_blank';
                        link.rel = 'noopener noreferrer';
                        link.textContent = 'Open on YouTube';
                        placeholder.replaceWith(fallback);
                    });

                    return container;
                }

                // YouTube short youtu.be links
                if (u.hostname === 'youtu.be') {
                    const vid = u.pathname.slice(1);
                    return this.createMediaEmbed(`https://www.youtube.com/watch?v=${vid}`, title);
                }
            } catch (e) {
                // ignore
            }
            // fallback: button that opens viewer in modal
            const btn = document.createElement('button');
            btn.type = 'button';
            btn.textContent = 'Open media';
            btn.addEventListener('click', () => this.openMediaViewer(url, title));
            return btn;
        };

        StudyFlowApp.prototype.openMediaViewer = function(url, title = '') {
            const content = document.createElement('div');
            const embed = this.createMediaEmbed(url, title);
            content.appendChild(embed);
            // Provide an explicit direct link (helpful when embedding is blocked)
            const direct = document.createElement('div');
            direct.style.marginTop = '12px';
            const viewLink = document.createElement('a');
            viewLink.href = url;
            viewLink.target = '_blank';
            viewLink.rel = 'noopener noreferrer';
            viewLink.textContent = 'Open media in a new tab';
            direct.appendChild(viewLink);

            this.modalTitle.textContent = title || 'Media Viewer';
            this.modalDesc.textContent = `Viewing media: ${url}`;
            this.modalContent.innerHTML = '';
            this.modalContent.appendChild(content);
            this.modalContent.appendChild(direct);
            this.modalConfirmBtn.textContent = 'Close';
            this.modalCancelBtn.textContent = 'Close';
            this._openModalCommon({ initialFocus: this.modalConfirmBtn, onConfirm: () => {}, onCancel: () => {} });
        };

        // Detect embedding environment and show guidance when necessary
        StudyFlowApp.prototype.checkEmbeddingEnvironment = function() {
            // If page is opened via file://, many embeds will fail due to missing Referer header
            if (location && location.protocol === 'file:') {
                // Create a persistent banner at top of app container
                const bannerId = 'embed-warning-banner';
                if (document.getElementById(bannerId)) return;
                const banner = document.createElement('div');
                banner.id = bannerId;
                banner.style.background = '#fff3cd';
                banner.style.border = '1px solid #ffeeba';
                banner.style.color = '#856404';
                banner.style.padding = '12px';
                banner.style.marginBottom = '12px';
                banner.style.borderRadius = '6px';
                banner.innerHTML = `
                    <strong>Embedding may be blocked</strong> — this page is opened from your file system (file://) and some embedded videos (YouTube) require a valid Referer. To preview media, serve the project locally and open <code>http://localhost:8000/index.html</code> instead.
                    <div style="margin-top:8px;">
                        <button id="embed-banner-show-instructions" type="button">Show instructions to run a local server</button>
                    </div>
                `;
                const container = document.querySelector('.container') || document.body;
                container.insertBefore(banner, container.firstChild);

                const btn = document.getElementById('embed-banner-show-instructions');
                btn.addEventListener('click', () => {
                    const help = `Run one of the following commands in the project root to serve files:\n\nPython 3:\npython -m http.server 8000\n\nNode (http-server):\nnpm install -g http-server\nhttp-server -p 8000`;
                    // Use modal to show instructions
                    this.openTextModal({ title: 'Run local server', label: 'Instructions', initialValue: help, confirmText: 'Close' });
                });
            }
        };
    </script>
</body>

</html>
